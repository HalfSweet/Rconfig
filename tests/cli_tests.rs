use std::fs;
use std::path::PathBuf;

fn fixture_path(name: &str) -> PathBuf {
    let base = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    base.join("target").join("tmp-tests").join(name)
}

fn write_file(path: &PathBuf, text: &str) {
    if let Some(parent) = path.parent() {
        let _ = fs::create_dir_all(parent);
    }
    fs::write(path, text).expect("write file");
}

#[test]
fn rcfg_dump_redacts_secret_by_default() {
    let schema = fixture_path("cli/schema.rcfg");
    let values = fixture_path("cli/values.rcfgv");
    let dump = fixture_path("cli/resolved.json");

    write_file(
        &schema,
        r#"
mod app {
  #[secret]
  option token: string = "abc";
}
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let text = fs::read_to_string(&dump).expect("read dump");
    assert!(
        text.contains("\"redacted\": true"),
        "secret should be redacted by default: {text}"
    );
}

#[test]
fn rcfg_export_generates_files() {
    let schema = fixture_path("cli_export/schema.rcfg");
    let values = fixture_path("cli_export/values.rcfgv");
    let out_h = fixture_path("cli_export/config.h");
    let out_cmake = fixture_path("cli_export/config.cmake");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
  option retries: u32 = 3;
}
"#,
    );
    write_file(
        &values,
        r#"
app::enabled = true;
app::retries = 8;
"#,
    );

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out-h",
            out_h.to_str().expect("header path"),
            "--out-cmake",
            out_cmake.to_str().expect("cmake path"),
        ])
        .status()
        .expect("run rcfg export");
    assert!(status.success(), "rcfg export should succeed");

    let header = fs::read_to_string(&out_h).expect("read header");
    let cmake = fs::read_to_string(&out_cmake).expect("read cmake");
    assert!(
        header.starts_with("#pragma once\n#ifndef RCFG_CONFIG_H\n#define RCFG_CONFIG_H\n/* Auto-generated by rcfg — do not edit */\n\n"),
        "{header}"
    );
    assert!(header.ends_with("\n#endif /* RCFG_CONFIG_H */"), "{header}");
    assert!(header.contains("#define CONFIG_APP_ENABLED 1"), "{header}");
    assert!(header.contains("#define CONFIG_APP_RETRIES 8"), "{header}");
    let expected_cmake_prelude = format!(
        "# Auto-generated by rcfg {} — do not edit\n\n",
        env!("CARGO_PKG_VERSION")
    );
    assert!(cmake.starts_with(&expected_cmake_prelude), "{cmake}");
    assert!(cmake.contains("set(CFG_APP_ENABLED ON)"), "{cmake}");
    assert!(cmake.contains("set(CFG_APP_RETRIES 8)"), "{cmake}");
}

#[test]
fn rcfg_export_omits_context_by_default_and_can_enable_it() {
    let schema = fixture_path("cli_export_context/schema.rcfg");
    let values = fixture_path("cli_export_context/values.rcfgv");
    let context = fixture_path("cli_export_context/context.json");
    let out_h_default = fixture_path("cli_export_context/config_default.h");
    let out_cmake_default = fixture_path("cli_export_context/config_default.cmake");
    let out_h_ctx = fixture_path("cli_export_context/config_ctx.h");
    let out_cmake_ctx = fixture_path("cli_export_context/config_ctx.cmake");

    write_file(
        &schema,
        r#"
mod ctx {
  option arch: string;
}

mod app {
  when ctx::arch == "arm" {
    option optimized: bool = true;
  }
}
"#,
    );
    write_file(&values, "");
    write_file(&context, r#"{"ctx::arch":"arm"}"#);

    let status_default = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--context",
            context.to_str().expect("context path"),
            "--out-h",
            out_h_default.to_str().expect("default header path"),
            "--out-cmake",
            out_cmake_default.to_str().expect("default cmake path"),
        ])
        .status()
        .expect("run rcfg export default");
    assert!(
        status_default.success(),
        "rcfg export default should succeed"
    );

    let header_default = fs::read_to_string(&out_h_default).expect("read default header");
    assert!(
        !header_default.contains("CONFIG_CTX_ARCH"),
        "ctx export should be disabled by default: {header_default}"
    );
    assert!(
        header_default.contains("#define CONFIG_APP_OPTIMIZED 1"),
        "expected app export in default header: {header_default}"
    );

    let status_with_ctx = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--context",
            context.to_str().expect("context path"),
            "--out-h",
            out_h_ctx.to_str().expect("context header path"),
            "--out-cmake",
            out_cmake_ctx.to_str().expect("context cmake path"),
            "--export-context",
        ])
        .status()
        .expect("run rcfg export with context");
    assert!(
        status_with_ctx.success(),
        "rcfg export with context should succeed"
    );

    let header_ctx = fs::read_to_string(&out_h_ctx).expect("read context header");
    let cmake_ctx = fs::read_to_string(&out_cmake_ctx).expect("read context cmake");
    assert!(
        header_ctx.contains("#define CONFIG_CTX_ARCH \"arm\""),
        "expected ctx define in header: {header_ctx}"
    );
    assert!(
        cmake_ctx.contains("set(CFG_CTX_ARCH \"arm\")"),
        "expected ctx define in cmake: {cmake_ctx}"
    );
}

#[test]
fn rcfg_export_can_use_path_only_name_rule() {
    let schema = fixture_path("cli_export_name_rule/schema.rcfg");
    let values = fixture_path("cli_export_name_rule/values.rcfgv");
    let out_h = fixture_path("cli_export_name_rule/config.h");
    let out_cmake = fixture_path("cli_export_name_rule/config.cmake");

    write_file(
        &schema,
        r#"
mod demo {
  mod app {
    option enabled: bool = true;
  }
}
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out-h",
            out_h.to_str().expect("header path"),
            "--out-cmake",
            out_cmake.to_str().expect("cmake path"),
            "--export-name-rule",
            "path-only",
        ])
        .status()
        .expect("run rcfg export");
    assert!(status.success(), "rcfg export should succeed");

    let header = fs::read_to_string(&out_h).expect("read header");
    let cmake = fs::read_to_string(&out_cmake).expect("read cmake");

    assert!(header.contains("#define CONFIG_APP_ENABLED 1"), "{header}");
    assert!(!header.contains("CONFIG_DEMO_APP_ENABLED"), "{header}");
    assert!(cmake.contains("set(CFG_APP_ENABLED ON)"), "{cmake}");
}

#[test]
fn rcfg_export_can_use_hex_style_for_integer() {
    let schema = fixture_path("cli_export_int_format/schema.rcfg");
    let values = fixture_path("cli_export_int_format/values.rcfgv");
    let out_h = fixture_path("cli_export_int_format/config.h");
    let out_cmake = fixture_path("cli_export_int_format/config.cmake");

    write_file(
        &schema,
        r#"
mod app {
  option retries: u32 = 3;
}
"#,
    );
    write_file(&values, "app::retries = 26;");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out-h",
            out_h.to_str().expect("header path"),
            "--out-cmake",
            out_cmake.to_str().expect("cmake path"),
            "--int-export-format",
            "hex",
        ])
        .status()
        .expect("run rcfg export");
    assert!(status.success(), "rcfg export should succeed");

    let header = fs::read_to_string(&out_h).expect("read header");
    let cmake = fs::read_to_string(&out_cmake).expect("read cmake");

    assert!(
        header.contains("#define CONFIG_APP_RETRIES 0x1A"),
        "{header}"
    );
    assert!(cmake.contains("set(CFG_APP_RETRIES 0x1A)"), "{cmake}");
}

#[test]
fn rcfg_export_can_use_string_style_for_enum() {
    let schema = fixture_path("cli_export_enum_style/schema.rcfg");
    let values = fixture_path("cli_export_enum_style/values.rcfgv");
    let out_h = fixture_path("cli_export_enum_style/config.h");
    let out_cmake = fixture_path("cli_export_enum_style/config.cmake");

    write_file(
        &schema,
        r#"
mod app {
  enum Mode { off, on }
  option mode: Mode = Mode::off;
}
"#,
    );
    write_file(&values, "app::mode = on;");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out-h",
            out_h.to_str().expect("header path"),
            "--out-cmake",
            out_cmake.to_str().expect("cmake path"),
            "--enum-export-style",
            "string",
        ])
        .status()
        .expect("run rcfg export");
    assert!(status.success(), "rcfg export should succeed");

    let header = fs::read_to_string(&out_h).expect("read header");
    let cmake = fs::read_to_string(&out_cmake).expect("read cmake");

    assert!(
        header.contains("#define CONFIG_APP_MODE \"app::Mode::on\""),
        "{header}"
    );
    assert!(
        !header.contains("CONFIG_APP_MODE_OFF") && !header.contains("CONFIG_APP_MODE_ON"),
        "{header}"
    );
    assert!(
        cmake.contains("set(CFG_APP_MODE \"app::Mode::on\")"),
        "{cmake}"
    );
}

#[test]
fn rcfg_export_can_define_zero_for_false_bool() {
    let schema = fixture_path("cli_export_bool_false/schema.rcfg");
    let values = fixture_path("cli_export_bool_false/values.rcfgv");
    let out_h = fixture_path("cli_export_bool_false/config.h");
    let out_cmake = fixture_path("cli_export_bool_false/config.cmake");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out-h",
            out_h.to_str().expect("header path"),
            "--out-cmake",
            out_cmake.to_str().expect("cmake path"),
            "--bool-false-style",
            "define-0",
        ])
        .status()
        .expect("run rcfg export");
    assert!(status.success(), "rcfg export should succeed");

    let header = fs::read_to_string(&out_h).expect("read header");
    let cmake = fs::read_to_string(&out_cmake).expect("read cmake");

    assert!(header.contains("#define CONFIG_APP_ENABLED 0"), "{header}");
    assert!(cmake.contains("set(CFG_APP_ENABLED OFF)"), "{cmake}");
}

#[test]
fn rcfg_export_supports_rust_format_output() {
    let schema = fixture_path("cli_export_rust/schema.rcfg");
    let values = fixture_path("cli_export_rust/values.rcfgv");
    let out_rust = fixture_path("cli_export_rust/config.rs");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
  option retries: u32 = 3;
  enum Mode { off, on }
  option mode: Mode = Mode::off;
}
"#,
    );
    write_file(
        &values,
        r#"
app::enabled = true;
app::retries = 8;
app::mode = on;
"#,
    );

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--format",
            "rust",
            "--out",
            out_rust.to_str().expect("rust output path"),
        ])
        .status()
        .expect("run rcfg export rust");
    assert!(status.success(), "rcfg export rust should succeed");

    let rust = fs::read_to_string(&out_rust).expect("read rust output");
    assert!(rust.starts_with("// Auto-generated by rcfg"), "{rust}");
    assert!(
        rust.contains("pub const CONFIG_APP_ENABLED: bool = true;"),
        "{rust}"
    );
    assert!(
        rust.contains("pub const CONFIG_APP_RETRIES: u32 = 8;"),
        "{rust}"
    );
    assert!(
        rust.contains("pub const CONFIG_APP_MODE: AppMode = AppMode::On;"),
        "{rust}"
    );
}

#[test]
fn rcfg_export_supports_python_format_output() {
    let schema = fixture_path("cli_export_python/schema.rcfg");
    let values = fixture_path("cli_export_python/values.rcfgv");
    let out_python = fixture_path("cli_export_python/config.py");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
  option retries: u16 = 3;
  enum Mode { off, on }
  option mode: Mode = Mode::off;
}
"#,
    );
    write_file(
        &values,
        r#"
app::enabled = true;
app::retries = 8;
app::mode = on;
"#,
    );

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--format",
            "python",
            "--out",
            out_python.to_str().expect("python output path"),
        ])
        .status()
        .expect("run rcfg export python");
    assert!(status.success(), "rcfg export python should succeed");

    let python = fs::read_to_string(&out_python).expect("read python output");
    assert!(python.starts_with("# Auto-generated by rcfg"), "{python}");
    assert!(python.contains("CONFIG_APP_ENABLED = True"), "{python}");
    assert!(python.contains("CONFIG_APP_RETRIES = 8"), "{python}");
    assert!(
        python.contains("CONFIG_APP_MODE = \"app::Mode::on\""),
        "{python}"
    );
}

#[test]
fn rcfg_export_supports_multiple_formats_in_one_run() {
    let schema = fixture_path("cli_export_multi/schema.rcfg");
    let values = fixture_path("cli_export_multi/values.rcfgv");
    let out_rust = fixture_path("cli_export_multi/config.rs");
    let out_python = fixture_path("cli_export_multi/config.py");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
  option retries: u32 = 3;
}
"#,
    );
    write_file(
        &values,
        r#"
app::enabled = true;
app::retries = 8;
"#,
    );

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--format",
            "rust",
            "--out",
            out_rust.to_str().expect("rust output path"),
            "--format",
            "python",
            "--out",
            out_python.to_str().expect("python output path"),
        ])
        .status()
        .expect("run rcfg export multi-format");
    assert!(status.success(), "rcfg export multi-format should succeed");

    let rust = fs::read_to_string(&out_rust).expect("read rust output");
    let python = fs::read_to_string(&out_python).expect("read python output");

    assert!(
        rust.contains("pub const CONFIG_APP_ENABLED: bool = true;"),
        "{rust}"
    );
    assert!(
        rust.contains("pub const CONFIG_APP_RETRIES: u32 = 8;"),
        "{rust}"
    );
    assert!(python.contains("CONFIG_APP_ENABLED = True"), "{python}");
    assert!(python.contains("CONFIG_APP_RETRIES = 8"), "{python}");
}

#[test]
fn rcfg_dump_writes_schema_ir_and_diagnostics_json() {
    let schema = fixture_path("cli_dump/schema.rcfg");
    let values = fixture_path("cli_dump/values.rcfgv");
    let dump = fixture_path("cli_dump/resolved.json");
    let schema_ir = fixture_path("cli_dump/schema_ir.json");
    let diagnostics = fixture_path("cli_dump/diagnostics.json");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(&values, "app::enabled = true;");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
            "--out-schema-ir",
            schema_ir.to_str().expect("schema_ir path"),
            "--out-diagnostics",
            diagnostics.to_str().expect("diagnostics path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let schema_ir_text = fs::read_to_string(&schema_ir).expect("read schema_ir");
    let diagnostics_text = fs::read_to_string(&diagnostics).expect("read diagnostics");
    assert!(schema_ir_text.contains("\"symbols\""), "{schema_ir_text}");
    assert!(
        diagnostics_text.contains("L_MISSING_DOC"),
        "{diagnostics_text}"
    );
}

#[test]
fn rcfg_schema_ir_splits_doc_summary_and_help() {
    let schema = fixture_path("cli_schema_ir_docs/schema.rcfg");
    let values = fixture_path("cli_schema_ir_docs/values.rcfgv");
    let dump = fixture_path("cli_schema_ir_docs/resolved.json");
    let schema_ir = fixture_path("cli_schema_ir_docs/schema_ir.json");

    write_file(
        &schema,
        r#"
/// App settings summary.
///
/// Detailed module help.
mod app {
  /// UART baud rate.
  ///
  /// Applied at startup.
  option baud: u32 = 115200;
}
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
            "--out-schema-ir",
            schema_ir.to_str().expect("schema_ir path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let schema_ir_text = fs::read_to_string(&schema_ir).expect("read schema_ir");
    assert!(
        schema_ir_text.contains("\"path\": \"app::baud\""),
        "{schema_ir_text}"
    );
    assert!(
        schema_ir_text.contains("\"summary\": \"UART baud rate.\""),
        "{schema_ir_text}"
    );
    assert!(
        schema_ir_text.contains("\"help\": \"Applied at startup.\""),
        "{schema_ir_text}"
    );
}

#[test]
fn rcfg_schema_ir_generates_i18n_keys_with_manifest_package() {
    let root = fixture_path("cli_schema_ir_i18n");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");
    let dump = root.join("resolved.json");
    let schema_ir = root.join("schema_ir.json");

    write_file(
        &schema,
        r#"
mod app {
  option baud: u32 = 115200;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
            "--out-schema-ir",
            schema_ir.to_str().expect("schema_ir path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let schema_ir_text = fs::read_to_string(&schema_ir).expect("read schema_ir");
    assert!(
        schema_ir_text.contains("\"path\": \"demo::app::baud\""),
        "{schema_ir_text}"
    );
    assert!(
        schema_ir_text.contains("\"label_key\": \"demo.app.baud.label\""),
        "{schema_ir_text}"
    );
    assert!(
        schema_ir_text.contains("\"help_key\": \"demo.app.baud.help\""),
        "{schema_ir_text}"
    );
}

#[test]
fn rcfg_schema_ir_honors_explicit_i18n_key_overrides() {
    let schema = fixture_path("cli_schema_ir_i18n_override/schema.rcfg");
    let values = fixture_path("cli_schema_ir_i18n_override/values.rcfgv");
    let dump = fixture_path("cli_schema_ir_i18n_override/resolved.json");
    let schema_ir = fixture_path("cli_schema_ir_i18n_override/schema_ir.json");

    write_file(
        &schema,
        r#"
mod app {
  #[label_key("demo.custom.baud.label")]
  #[help_key("demo.custom.baud.help")]
  /// UART baud rate.
  ///
  /// Applied at startup.
  option baud: u32 = 115200;
}
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
            "--out-schema-ir",
            schema_ir.to_str().expect("schema_ir path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let schema_ir_text = fs::read_to_string(&schema_ir).expect("read schema_ir");
    assert!(
        schema_ir_text.contains("\"label_key\": \"demo.custom.baud.label\""),
        "{schema_ir_text}"
    );
    assert!(
        schema_ir_text.contains("\"help_key\": \"demo.custom.baud.help\""),
        "{schema_ir_text}"
    );
    assert!(
        !schema_ir_text.contains("\"label_key\": \"main.app.baud.label\""),
        "default key should be overridden: {schema_ir_text}"
    );
}

#[test]
fn rcfg_dump_resolved_paths_include_manifest_package_prefix() {
    let root = fixture_path("cli_dump_pkg_prefix");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");
    let dump = root.join("resolved.json");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let text = fs::read_to_string(&dump).expect("read resolved dump");
    assert!(text.contains("\"demo::app::enabled\""), "{text}");
}

#[test]
fn rcfg_check_supports_manifest_entry_schema() {
    let root = fixture_path("cli_manifest");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&values, "app::enabled = true;");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
            "--format",
            "json",
        ])
        .output()
        .expect("run rcfg check");
    assert!(output.status.success(), "rcfg check should succeed");
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("L_MISSING_DOC"), "{stdout}");
}

#[test]
fn rcfg_check_supports_root_prefixed_include_with_manifest_root() {
    let root = fixture_path("cli_manifest_include_root");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let base_values = root.join("profiles/common.rcfgv");
    let values = root.join("profiles/dev/values.rcfgv");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&base_values, "app::enabled = true;\n");
    write_file(&values, "include \"@root/profiles/common.rcfgv\";\n");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
            "--format",
            "json",
        ])
        .status()
        .expect("run rcfg check");
    assert!(status.success(), "rcfg check should succeed");
}

#[test]
fn rcfg_check_manifest_requires_package_version() {
    let root = fixture_path("cli_manifest_missing_version");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&values, "app::enabled = true;");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("manifest missing package.version"),
        "{stderr}"
    );
}

#[test]
fn rcfg_check_manifest_requires_existing_entry_schema_file() {
    let root = fixture_path("cli_manifest_missing_entry_schema");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/missing.rcfg"
"#,
    );
    write_file(&values, "");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("manifest entry schema does not exist"),
        "{stderr}"
    );
}

#[test]
fn rcfg_check_accepts_manifest_dependencies_path_table() {
    let root = fixture_path("cli_manifest_dependencies");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    let hal_manifest = root.join("deps/hal_uart/Config.toml");
    let hal_schema = root.join("deps/hal_uart/src/schema.rcfg");

    let platform_manifest = root.join("deps/platform/Config.toml");
    let platform_schema = root.join("deps/platform/src/schema.rcfg");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &hal_schema,
        "mod hal_uart { option enabled: bool = false; }",
    );
    write_file(
        &platform_schema,
        "mod platform { option enabled: bool = false; }",
    );

    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
hal_uart = "deps/hal_uart"
platform = "deps/platform"
"#,
    );
    write_file(
        &hal_manifest,
        r#"
[package]
name = "hal_uart"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(
        &platform_manifest,
        r#"
[package]
name = "platform"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&values, "");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
            "--format",
            "json",
        ])
        .output()
        .expect("run rcfg check");
    assert!(output.status.success(), "rcfg check should succeed");
}

#[test]
fn rcfg_check_rejects_manifest_dependencies_non_string_path() {
    let root = fixture_path("cli_manifest_dependencies_invalid");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
hal_uart = { path = "../deps/hal_uart" }
"#,
    );
    write_file(&values, "");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("manifest dependency `hal_uart` must be a path string"),
        "{stderr}"
    );
}

#[test]
fn rcfg_i18n_extract_generates_template_toml() {
    let root = fixture_path("cli_i18n_extract");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let out = root.join("i18n/zh-CN.toml");

    write_file(
        &schema,
        r#"
/// App settings.
///
/// Long module help.
mod app {
  /// Enable feature.
  option enabled: bool = false;

  /// Baud mode.
  enum mode {
    /// Fast mode.
    Fast,
  }

  #[msg("demo.app.require.custom")]
  require!(enabled == false);
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "i18n",
            "extract",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--out",
            out.to_str().expect("out path"),
            "--locale",
            "zh-CN",
        ])
        .status()
        .expect("run rcfg i18n extract");
    assert!(status.success(), "rcfg i18n extract should succeed");

    let text = fs::read_to_string(&out).expect("read i18n template");
    assert!(text.contains("locale = \"zh-CN\""), "{text}");
    assert!(
        text.contains("\"demo.app.label\" = \"App settings.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.help\" = \"Long module help.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.enabled.label\" = \"Enable feature.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.mode.label\" = \"Baud mode.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.mode.Fast.label\" = \"Fast mode.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.require.custom\" = \"require condition failed\""),
        "{text}"
    );
}

#[test]
fn rcfg_i18n_extract_honors_explicit_symbol_key_overrides() {
    let root = fixture_path("cli_i18n_extract_override");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let out = root.join("i18n/en.toml");

    write_file(
        &schema,
        r#"
mod app {
  #[label_key("demo.custom.enabled.label")]
  #[help_key("demo.custom.enabled.help")]
  /// Enable feature.
  ///
  /// Detailed option help.
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "i18n",
            "extract",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--out",
            out.to_str().expect("out path"),
            "--locale",
            "en",
        ])
        .status()
        .expect("run rcfg i18n extract");
    assert!(status.success(), "rcfg i18n extract should succeed");

    let text = fs::read_to_string(&out).expect("read i18n template");
    assert!(
        text.contains("\"demo.custom.enabled.label\" = \"Enable feature.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.custom.enabled.help\" = \"Detailed option help.\""),
        "{text}"
    );
    assert!(
        !text.contains("\"demo.app.enabled.label\""),
        "default key should be overridden: {text}"
    );
}

#[test]
fn rcfg_check_uses_i18n_message_fallback() {
    let root = fixture_path("cli_i18n_fallback");
    let schema = root.join("schema.rcfg");
    let values = root.join("values.rcfgv");
    let i18n = root.join("i18n/zh-CN.toml");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;

  #[msg("demo.app.require.fail")]
  require!(enabled == true);
}
"#,
    );
    write_file(&values, "");
    write_file(
        &i18n,
        r#"
locale = "zh-CN"

[strings]
"demo.app.require.fail" = "需要启用 app::enabled"
"#,
    );

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--i18n",
            i18n.to_str().expect("i18n path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("需要启用 app::enabled"), "{stdout}");
}

#[test]
fn rcfg_check_loads_dependency_package_schema_from_manifest_graph() {
    let root = fixture_path("cli_manifest_dep_graph");
    let app_schema = root.join("app/src/schema.rcfg");
    let app_manifest = root.join("app/Config.toml");
    let values = root.join("app/values.rcfgv");

    let dep_manifest = root.join("deps/hal_uart/Config.toml");
    let dep_schema = root.join("deps/hal_uart/src/schema.rcfg");

    write_file(
        &dep_schema,
        r#"
mod hal_uart {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &dep_manifest,
        r#"
[package]
name = "hal_uart"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );

    write_file(
        &app_schema,
        r#"
mod app {
  option enabled: bool = false;
}

require!(hal_uart::enabled == false);
"#,
    );
    write_file(
        &app_manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
hal_uart = "../deps/hal_uart"
"#,
    );
    write_file(
        &values,
        r#"
demo::app::enabled = true;
hal_uart::hal_uart::enabled = true;
"#,
    );

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            app_manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(
        stdout.contains("E_REQUIRE_FAILED"),
        "cross-package require should evaluate dependency option: {stdout}"
    );
}

#[test]
fn rcfg_check_reports_package_cycle_from_manifest_dependencies() {
    let root = fixture_path("cli_manifest_dep_cycle");
    let app_schema = root.join("app/src/schema.rcfg");
    let app_manifest = root.join("app/Config.toml");
    let values = root.join("app/values.rcfgv");

    let dep_a_manifest = root.join("deps/dep_a/Config.toml");
    let dep_a_schema = root.join("deps/dep_a/src/schema.rcfg");

    let dep_b_manifest = root.join("deps/dep_b/Config.toml");
    let dep_b_schema = root.join("deps/dep_b/src/schema.rcfg");

    write_file(&app_schema, "mod app { option enabled: bool = false; }");
    write_file(&dep_a_schema, "mod dep_a { option enabled: bool = false; }");
    write_file(&dep_b_schema, "mod dep_b { option enabled: bool = false; }");

    write_file(
        &app_manifest,
        r#"
[package]
name = "app"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
dep_a = "../deps/dep_a"
"#,
    );
    write_file(
        &dep_a_manifest,
        r#"
[package]
name = "dep_a"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
dep_b = "../dep_b"
"#,
    );
    write_file(
        &dep_b_manifest,
        r#"
[package]
name = "dep_b"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
dep_a = "../dep_a"
"#,
    );
    write_file(&values, "");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            app_manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("E_PACKAGE_CYCLE"), "{stderr}");
}

#[test]
fn rcfg_export_skips_rewrite_when_output_unchanged() {
    let schema = fixture_path("cli_export_no_rewrite/schema.rcfg");
    let values = fixture_path("cli_export_no_rewrite/values.rcfgv");
    let out_h = fixture_path("cli_export_no_rewrite/config.h");
    let out_cmake = fixture_path("cli_export_no_rewrite/config.cmake");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = true;
}
"#,
    );
    write_file(&values, "");

    let first = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out-h",
            out_h.to_str().expect("header path"),
            "--out-cmake",
            out_cmake.to_str().expect("cmake path"),
        ])
        .status()
        .expect("run first rcfg export");
    assert!(first.success(), "first rcfg export should succeed");

    let first_h_mtime = fs::metadata(&out_h)
        .expect("stat header")
        .modified()
        .expect("header mtime");
    let first_cmake_mtime = fs::metadata(&out_cmake)
        .expect("stat cmake")
        .modified()
        .expect("cmake mtime");

    std::thread::sleep(std::time::Duration::from_millis(1200));

    let second = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out-h",
            out_h.to_str().expect("header path"),
            "--out-cmake",
            out_cmake.to_str().expect("cmake path"),
        ])
        .status()
        .expect("run second rcfg export");
    assert!(second.success(), "second rcfg export should succeed");

    let second_h_mtime = fs::metadata(&out_h)
        .expect("stat header again")
        .modified()
        .expect("header mtime again");
    let second_cmake_mtime = fs::metadata(&out_cmake)
        .expect("stat cmake again")
        .modified()
        .expect("cmake mtime again");

    assert_eq!(
        first_h_mtime, second_h_mtime,
        "header should not be rewritten"
    );
    assert_eq!(
        first_cmake_mtime, second_cmake_mtime,
        "cmake should not be rewritten"
    );
}

#[test]
fn cmake_can_consume_exported_config_module() {
    if std::process::Command::new("cmake")
        .arg("--version")
        .status()
        .is_err()
    {
        eprintln!("cmake not found, skip integration validation");
        return;
    }

    let root = fixture_path("cli_cmake_integration");
    let schema = root.join("schema.rcfg");
    let values = root.join("values.rcfgv");
    let out_h = root.join("config.h");
    let out_cmake = root.join("config.cmake");
    let script = root.join("check.cmake");
    let result = root.join("result.txt");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
  option retries: u32 = 3;
}
"#,
    );
    write_file(
        &values,
        r#"
app::enabled = true;
app::retries = 8;
"#,
    );

    let export_status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out-h",
            out_h.to_str().expect("header path"),
            "--out-cmake",
            out_cmake.to_str().expect("cmake path"),
        ])
        .status()
        .expect("run rcfg export");
    assert!(export_status.success(), "rcfg export should succeed");

    write_file(
        &script,
        format!(
            r#"
include("{}")
file(WRITE "{}" "${{CFG_APP_ENABLED}};${{CFG_APP_RETRIES}}")
"#,
            out_cmake.to_string_lossy(),
            result.to_string_lossy()
        )
        .as_str(),
    );

    let cmake_status = std::process::Command::new("cmake")
        .args(["-P", script.to_str().expect("script path")])
        .status()
        .expect("run cmake script");
    assert!(cmake_status.success(), "cmake -P should succeed");

    let rendered = fs::read_to_string(&result).expect("read cmake result");
    assert_eq!(rendered, "ON;8");
}
