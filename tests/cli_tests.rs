use std::fs;
use std::path::PathBuf;

fn fixture_path(name: &str) -> PathBuf {
    let base = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    base.join("target").join("tmp-tests").join(name)
}

fn write_file(path: &PathBuf, text: &str) {
    if let Some(parent) = path.parent() {
        let _ = fs::create_dir_all(parent);
    }
    fs::write(path, text).expect("write file");
}

#[test]
fn rcfg_dump_redacts_secret_by_default() {
    let schema = fixture_path("cli/schema.rcfg");
    let values = fixture_path("cli/values.rcfgv");
    let dump = fixture_path("cli/resolved.json");

    write_file(
        &schema,
        r#"
mod app {
  #[secret]
  option token: string = "abc";
}
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let text = fs::read_to_string(&dump).expect("read dump");
    assert!(
        text.contains("\"redacted\": true"),
        "secret should be redacted by default: {text}"
    );
}

#[test]
fn rcfg_export_generates_files() {
    let schema = fixture_path("cli_export/schema.rcfg");
    let values = fixture_path("cli_export/values.rcfgv");
    let out_h = fixture_path("cli_export/config.h");
    let out_cmake = fixture_path("cli_export/config.cmake");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
  option retries: u32 = 3;
}
"#,
    );
    write_file(
        &values,
        r#"
app::enabled = true;
app::retries = 8;
"#,
    );

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "export",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out-h",
            out_h.to_str().expect("header path"),
            "--out-cmake",
            out_cmake.to_str().expect("cmake path"),
        ])
        .status()
        .expect("run rcfg export");
    assert!(status.success(), "rcfg export should succeed");

    let header = fs::read_to_string(&out_h).expect("read header");
    let cmake = fs::read_to_string(&out_cmake).expect("read cmake");
    assert!(
        header.starts_with("#pragma once\n#ifndef RCFG_CONFIG_H\n#define RCFG_CONFIG_H\n/* Auto-generated by rcfg — do not edit */\n\n"),
        "{header}"
    );
    assert!(header.ends_with("\n#endif /* RCFG_CONFIG_H */"), "{header}");
    assert!(header.contains("#define CONFIG_APP_ENABLED 1"), "{header}");
    assert!(header.contains("#define CONFIG_APP_RETRIES 8"), "{header}");
    assert!(cmake.contains("set(CFG_APP_ENABLED ON)"), "{cmake}");
    assert!(cmake.contains("set(CFG_APP_RETRIES 8)"), "{cmake}");
}

#[test]
fn rcfg_dump_writes_schema_ir_and_diagnostics_json() {
    let schema = fixture_path("cli_dump/schema.rcfg");
    let values = fixture_path("cli_dump/values.rcfgv");
    let dump = fixture_path("cli_dump/resolved.json");
    let schema_ir = fixture_path("cli_dump/schema_ir.json");
    let diagnostics = fixture_path("cli_dump/diagnostics.json");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(&values, "app::enabled = true;");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
            "--out-schema-ir",
            schema_ir.to_str().expect("schema_ir path"),
            "--out-diagnostics",
            diagnostics.to_str().expect("diagnostics path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let schema_ir_text = fs::read_to_string(&schema_ir).expect("read schema_ir");
    let diagnostics_text = fs::read_to_string(&diagnostics).expect("read diagnostics");
    assert!(schema_ir_text.contains("\"symbols\""), "{schema_ir_text}");
    assert!(
        diagnostics_text.contains("L_MISSING_DOC"),
        "{diagnostics_text}"
    );
}

#[test]
fn rcfg_schema_ir_splits_doc_summary_and_help() {
    let schema = fixture_path("cli_schema_ir_docs/schema.rcfg");
    let values = fixture_path("cli_schema_ir_docs/values.rcfgv");
    let dump = fixture_path("cli_schema_ir_docs/resolved.json");
    let schema_ir = fixture_path("cli_schema_ir_docs/schema_ir.json");

    write_file(
        &schema,
        r#"
/// App settings summary.
///
/// Detailed module help.
mod app {
  /// UART baud rate.
  ///
  /// Applied at startup.
  option baud: u32 = 115200;
}
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
            "--out-schema-ir",
            schema_ir.to_str().expect("schema_ir path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let schema_ir_text = fs::read_to_string(&schema_ir).expect("read schema_ir");
    assert!(
        schema_ir_text.contains("\"path\": \"app::baud\""),
        "{schema_ir_text}"
    );
    assert!(
        schema_ir_text.contains("\"summary\": \"UART baud rate.\""),
        "{schema_ir_text}"
    );
    assert!(
        schema_ir_text.contains("\"help\": \"Applied at startup.\""),
        "{schema_ir_text}"
    );
}

#[test]
fn rcfg_schema_ir_generates_i18n_keys_with_manifest_package() {
    let root = fixture_path("cli_schema_ir_i18n");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");
    let dump = root.join("resolved.json");
    let schema_ir = root.join("schema_ir.json");

    write_file(
        &schema,
        r#"
mod app {
  option baud: u32 = 115200;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
            "--out-schema-ir",
            schema_ir.to_str().expect("schema_ir path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let schema_ir_text = fs::read_to_string(&schema_ir).expect("read schema_ir");
    assert!(
        schema_ir_text.contains("\"path\": \"demo::app::baud\""),
        "{schema_ir_text}"
    );
    assert!(
        schema_ir_text.contains("\"label_key\": \"demo.app.baud.label\""),
        "{schema_ir_text}"
    );
    assert!(
        schema_ir_text.contains("\"help_key\": \"demo.app.baud.help\""),
        "{schema_ir_text}"
    );
}

#[test]
fn rcfg_dump_resolved_paths_include_manifest_package_prefix() {
    let root = fixture_path("cli_dump_pkg_prefix");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");
    let dump = root.join("resolved.json");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&values, "");

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "dump",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
            "--out",
            dump.to_str().expect("dump path"),
        ])
        .status()
        .expect("run rcfg dump");
    assert!(status.success(), "rcfg dump should succeed");

    let text = fs::read_to_string(&dump).expect("read resolved dump");
    assert!(text.contains("\"demo::app::enabled\""), "{text}");
}

#[test]
fn rcfg_check_supports_manifest_entry_schema() {
    let root = fixture_path("cli_manifest");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&values, "app::enabled = true;");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
            "--format",
            "json",
        ])
        .output()
        .expect("run rcfg check");
    assert!(output.status.success(), "rcfg check should succeed");
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("L_MISSING_DOC"), "{stdout}");
}

#[test]
fn rcfg_check_manifest_requires_package_version() {
    let root = fixture_path("cli_manifest_missing_version");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"

[entry]
schema = "src/schema.rcfg"
"#,
    );
    write_file(&values, "app::enabled = true;");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("manifest missing package.version"),
        "{stderr}"
    );
}

#[test]
fn rcfg_check_manifest_requires_existing_entry_schema_file() {
    let root = fixture_path("cli_manifest_missing_entry_schema");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/missing.rcfg"
"#,
    );
    write_file(&values, "");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("manifest entry schema does not exist"),
        "{stderr}"
    );
}

#[test]
fn rcfg_check_accepts_manifest_dependencies_path_table() {
    let root = fixture_path("cli_manifest_dependencies");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
hal_uart = "../deps/hal_uart"
platform = "../deps/platform"
"#,
    );
    write_file(&values, "");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
            "--format",
            "json",
        ])
        .output()
        .expect("run rcfg check");
    assert!(output.status.success(), "rcfg check should succeed");
}

#[test]
fn rcfg_check_rejects_manifest_dependencies_non_string_path() {
    let root = fixture_path("cli_manifest_dependencies_invalid");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let values = root.join("values.rcfgv");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
hal_uart = { path = "../deps/hal_uart" }
"#,
    );
    write_file(&values, "");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("manifest dependency `hal_uart` must be a path string"),
        "{stderr}"
    );
}

#[test]
fn rcfg_i18n_extract_generates_template_toml() {
    let root = fixture_path("cli_i18n_extract");
    let schema = root.join("src/schema.rcfg");
    let manifest = root.join("Config.toml");
    let out = root.join("i18n/zh-CN.toml");

    write_file(
        &schema,
        r#"
/// App settings.
///
/// Long module help.
mod app {
  /// Enable feature.
  option enabled: bool = false;

  /// Baud mode.
  enum mode {
    /// Fast mode.
    Fast,
  }

  #[msg("demo.app.require.custom")]
  require!(enabled == false);
}
"#,
    );
    write_file(
        &manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );

    let status = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "i18n",
            "extract",
            "--manifest",
            manifest.to_str().expect("manifest path"),
            "--out",
            out.to_str().expect("out path"),
            "--locale",
            "zh-CN",
        ])
        .status()
        .expect("run rcfg i18n extract");
    assert!(status.success(), "rcfg i18n extract should succeed");

    let text = fs::read_to_string(&out).expect("read i18n template");
    assert!(text.contains("locale = \"zh-CN\""), "{text}");
    assert!(
        text.contains("\"demo.app.label\" = \"App settings.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.help\" = \"Long module help.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.enabled.label\" = \"Enable feature.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.mode.label\" = \"Baud mode.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.mode.Fast.label\" = \"Fast mode.\""),
        "{text}"
    );
    assert!(
        text.contains("\"demo.app.require.custom\" = \"require condition failed\""),
        "{text}"
    );
}

#[test]
fn rcfg_check_uses_i18n_message_fallback() {
    let root = fixture_path("cli_i18n_fallback");
    let schema = root.join("schema.rcfg");
    let values = root.join("values.rcfgv");
    let i18n = root.join("i18n/zh-CN.toml");

    write_file(
        &schema,
        r#"
mod app {
  option enabled: bool = false;

  #[msg("demo.app.require.fail")]
  require!(enabled == true);
}
"#,
    );
    write_file(&values, "");
    write_file(
        &i18n,
        r#"
locale = "zh-CN"

[strings]
"demo.app.require.fail" = "需要启用 app::enabled"
"#,
    );

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--schema",
            schema.to_str().expect("schema path"),
            "--values",
            values.to_str().expect("values path"),
            "--i18n",
            i18n.to_str().expect("i18n path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("需要启用 app::enabled"), "{stdout}");
}

#[test]
fn rcfg_check_loads_dependency_package_schema_from_manifest_graph() {
    let root = fixture_path("cli_manifest_dep_graph");
    let app_schema = root.join("app/src/schema.rcfg");
    let app_manifest = root.join("app/Config.toml");
    let values = root.join("app/values.rcfgv");

    let dep_manifest = root.join("deps/hal_uart/Config.toml");
    let dep_schema = root.join("deps/hal_uart/src/schema.rcfg");

    write_file(
        &dep_schema,
        r#"
mod hal_uart {
  option enabled: bool = false;
}
"#,
    );
    write_file(
        &dep_manifest,
        r#"
[package]
name = "hal_uart"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"
"#,
    );

    write_file(
        &app_schema,
        r#"
mod app {
  option enabled: bool = false;
}

require!(hal_uart::enabled == false);
"#,
    );
    write_file(
        &app_manifest,
        r#"
[package]
name = "demo"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
hal_uart = "../deps/hal_uart"
"#,
    );
    write_file(
        &values,
        r#"
demo::app::enabled = true;
hal_uart::hal_uart::enabled = true;
"#,
    );

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            app_manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(
        stdout.contains("E_REQUIRE_FAILED"),
        "cross-package require should evaluate dependency option: {stdout}"
    );
}

#[test]
fn rcfg_check_reports_package_cycle_from_manifest_dependencies() {
    let root = fixture_path("cli_manifest_dep_cycle");
    let app_schema = root.join("app/src/schema.rcfg");
    let app_manifest = root.join("app/Config.toml");
    let values = root.join("app/values.rcfgv");

    let dep_a_manifest = root.join("deps/dep_a/Config.toml");
    let dep_a_schema = root.join("deps/dep_a/src/schema.rcfg");

    let dep_b_manifest = root.join("deps/dep_b/Config.toml");
    let dep_b_schema = root.join("deps/dep_b/src/schema.rcfg");

    write_file(&app_schema, "mod app { option enabled: bool = false; }");
    write_file(&dep_a_schema, "mod dep_a { option enabled: bool = false; }");
    write_file(&dep_b_schema, "mod dep_b { option enabled: bool = false; }");

    write_file(
        &app_manifest,
        r#"
[package]
name = "app"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
dep_a = "../deps/dep_a"
"#,
    );
    write_file(
        &dep_a_manifest,
        r#"
[package]
name = "dep_a"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
dep_b = "../dep_b"
"#,
    );
    write_file(
        &dep_b_manifest,
        r#"
[package]
name = "dep_b"
version = "0.1.0"

[entry]
schema = "src/schema.rcfg"

[dependencies]
dep_a = "../dep_a"
"#,
    );
    write_file(&values, "");

    let output = std::process::Command::new(env!("CARGO_BIN_EXE_rcfg"))
        .args([
            "check",
            "--manifest",
            app_manifest.to_str().expect("manifest path"),
            "--values",
            values.to_str().expect("values path"),
        ])
        .output()
        .expect("run rcfg check");
    assert!(!output.status.success(), "rcfg check should fail");

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("E_PACKAGE_CYCLE"), "{stderr}");
}
